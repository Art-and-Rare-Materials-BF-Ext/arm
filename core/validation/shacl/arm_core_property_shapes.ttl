@prefix activity: <https://w3id.org/arm/core/activity/0.1/> .
@prefix arm: <https://w3id.org/arm/core/ontology/0.1/> .
@prefix bf: <http://id.loc.gov/ontologies/bibframe/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix swa: <http://topbraid.org/swa#> .
@prefix tosh: <http://topbraid.org/tosh#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix : <https://w3id.org/arm/core/validation/shacl/arm_core_property_shapes/> .

#
# ///// ARM CORE PROPERTY SHAPES - MAY BE EXTENDED BY UI SHAPES ///// #
#

# 
# TODO 
#
# - If this file grows too large, break up in some way - 
# maybe by ontology namespace - i.e., BF properties, ARM properties, etc.?
# - Should dates be typed edtf:EDTF, or is it just recommended?
#

:activity_hasActivity 
    a sh:PropertyShape ;
    sh:path arm:hasActivity ;
    sh:nodeKind sh:IRI ; 
    sh:class arm:Activity ;
    .

:activity_isActivityOf 
    a sh:PropertyShape ;
    sh:path activity:isActivityOf ;
    sh:nodeKind sh:IRI ; 
    .   
    
:arm_atLocation
    a sh:PropertyShape ;
    sh:path arm:atLocation ;
    sh:nodeKind sh:IRI ;
    .
    
:arm_covers
    a sh:PropertyShape ;
    sh:path arm:covers ;
    sh:nodeKind sh:IRI ;
    .
    
:arm_endDate 
    a sh:PropertyShape ;
    sh:path arm:endDate ;
    sh:nodeKind sh:Literal ; 
    # sh:datatype edtf:EDTF ; 
    sh:maxCount 1 ;
    .

:arm_hasArrangement 
    a sh:PropertyShape ;
    sh:path arm:hasArrangement ;
    sh:nodeKind sh:IRI ; 
    sh:class arm:Arrangement ;
    .
      
:arm_markedBy 
    a sh:PropertyShape ;
    sh:path arm:markedBy ;
    sh:nodeKind sh:IRI ; 
    # Assumes the object type options are the same in all contexts. 
    # Remove if the assumption proves false.
    sh:class [
        sh:in (
            arm:Enclosure
            arm:Binding
            arm:DustJacket
            arm:SlipCase
            arm:WrapAroundBand
            arm:Wrapper         
        )
    ]
    .
        
:arm_startDate 
    a sh:PropertyShape ;
    sh:path arm:startDate ;
    sh:nodeKind sh:Literal ;
    # sh:datatype edtf:EDTF ; 
    sh:maxCount 1 ;
    .

:bf_agent
    a sh:PropertyShape ;
    sh:path bf:agent ;
    sh:class bf:Agent ;
    sh:nodeKind sh:IRI ;
    # An Activity always has a unique agent. But might we use bf:agent with 
    # other subject types, where it wouldn't be unique?
    # sh:maxCount 1 ;
    .
    
:bf_date
    a sh:PropertyShape ;
    sh:path bf:date ;
    sh:nodeKind sh:Literal ;
    # Recommended but not required
    # sh:datatype edtf:EDTF ;
    .
    
:bf_identifiedBy
    a sh:PropertyShape ;
    sh:path bf:identifiedBy ;
    sh:nodeKind sh:IRI ;
    sh:class bf:Identifier ;
    .
       
:bf_note
    a sh:PropertyShape ;
    sh:path bf:note ;
    sh:nodeKind sh:IRI ;
    # sh:class determined by note context, so omit here  
    .
    
:bf_subject
    a sh:PropertyShape ;
    sh:path bf:subject ;
    sh:nodeKind sh:IRI ;
    .
       
:bf_title 
    a sh:PropertyShape ;
    sh:path bf:title ;
    sh:nodeKind sh:IRI ; 
    sh:class bf:Title ;
    . 
    
:dcterms_hasPart
    a sh:PropertyShape ;
    sh:path dcterms:hasPart ;
    # Not required by the predicate (which is an RDF property) but this is how our models use it.
    sh:nodeKind sh:IRI ;
    .

# dcterms:hasPart shape for object type arm:Enclosure  
:dcterms_hasPart_arm_Enclosure
    sh:and (
        :dcterms_hasPart   
        [
            # Assumes the object type options are the same in all contexts. 
            # Remove if the assumption proves false.
            sh:class [
                sh:in (
                    arm:Enclosure
                    arm:Binding
                    arm:DustJacket
                    arm:SlipCase
                    arm:WrapAroundBand
                    arm:Wrapper         
                )
            ]
        ]
    )
    .
        
:dcterms_isPartOf
    a sh:PropertyShape ;
    sh:path dcterms:isPartOf ;
    # Not required by the predicate (which is an RDF property), but this is how our models use it.
    sh:nodeKind sh:IRI ;
    .
    
:rdf_type
    a sh:PropertyShape ;
    sh:path rdf:type ;
    sh:nodeKind sh:IRI ;
    .
    
:rdf_value
    a sh:PropertyShape ;
    sh:path rdf:value ;
    # Not required by the predicate, but this is how our models use it.
    sh:nodeKind sh:IRI ;
    .
