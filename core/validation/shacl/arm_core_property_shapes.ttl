@prefix aat: <http://vocab.getty.edu/aat/> .
@prefix activity: <https://w3id.org/arm/core/activity/0.1/> .
@prefix arm: <https://w3id.org/arm/core/ontology/0.1/> .
@prefix bf: <http://id.loc.gov/ontologies/bibframe/> .
@prefix crm: <http://www.cidoc-crm.org/Property/P2-has-type/Version-6.2/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix : <https://w3id.org/arm/core/validation/shacl/arm_core_property_shapes/> .

#
# ///// ARM CORE PROPERTY SHAPES - MAY BE EXTENDED BY UI SHAPES ///// #
#

# 
# TODO/TO CONSIDER
#
# If this file grows too large, break up in some way - 
# maybe by ontology namespace - i.e., BF properties, ARM properties, etc.?
#
# Not requiring edtf:EDTF typing of dates - indicate on forms that it is
# recommended.
#
# These are only preliminary validation shapes. Add more constraints later.
#

:activity_hasActivity 
    a sh:PropertyShape ;
    sh:path arm:hasActivity ;
    sh:nodeKind sh:IRI ; 
    sh:class arm:Activity ;
    .

:activity_isActivityOf 
    a sh:PropertyShape ;
    sh:path activity:isActivityOf ;
    sh:nodeKind sh:IRI ; 
    .   
    
:arm_atLocation
    a sh:PropertyShape ;
    sh:path arm:atLocation ;
    sh:nodeKind sh:IRI ;
    .
    
:arm_covers
    a sh:PropertyShape ;
    sh:path arm:covers ;
    sh:nodeKind sh:IRI ;
    .
    
:arm_endDate 
    a sh:PropertyShape ;
    sh:path arm:endDate ;
    sh:nodeKind sh:Literal ; 
    # sh:datatype edtf:EDTF ; 
    sh:maxCount 1 ;
    .

:arm_hasArrangement 
    a sh:PropertyShape ;
    sh:path arm:hasArrangement ;
    sh:nodeKind sh:IRI ; 
    sh:class arm:Arrangement ;
    .
    
:arm_hasMaterial 
    a sh:PropertyShape ;
    sh:path arm:hasMaterial ;
    sh:nodeKind sh:IRI ; 
    sh:class crm:E57 ;
    .

:arm_isAgentOf
    a sh:PropertyShape ;
    sh:path arm:isAgentOf ;
    sh:nodeKind sh:IRI ;
    .
              
:arm_markedBy 
    a sh:PropertyShape ;
    sh:path arm:markedBy ;
    sh:nodeKind sh:IRI ; 
    sh:class arm:Enclosure ;
    .
        
:arm_startDate 
    a sh:PropertyShape ;
    sh:path arm:startDate ;
    sh:nodeKind sh:Literal ;
    # sh:datatype edtf:EDTF ; 
    sh:maxCount 1 ;
    .

:bf_agent
    a sh:PropertyShape ;
    sh:path bf:agent ;
    sh:class bf:Agent ;
    sh:nodeKind sh:IRI ;
    # An Activity always has a unique agent. But might we use bf:agent with 
    # other subject types, where it wouldn't be unique?
    # sh:maxCount 1 ;
    .
    
:bf_date
    a sh:PropertyShape ;
    sh:path bf:date ;
    sh:nodeKind sh:Literal ;
    # Recommended but not required
    # sh:datatype edtf:EDTF ;
    .
    
 :bf_hasPart
    a sh:PropertyShape ;
    sh:path bf:hasPart;
    sh:nodeKind sh:IRI ;
    .
    
:bf_identifiedBy
    a sh:PropertyShape ;
    sh:path bf:identifiedBy ;
    sh:nodeKind sh:IRI ;
    sh:class bf:Identifier ;
    .
       
:bf_note
    a sh:PropertyShape ;
    sh:path bf:note ;
    sh:nodeKind sh:IRI ;
    sh:class bf:Note ;  
    .

:bf_partOf
    a sh:PropertyShape ;
    sh:path bf:partOf ;
    sh:nodeKind sh:IRI ;
    .

:bf_status 
    a sh:PropertyShape ;
    sh:path bf:status ;
    sh:nodeKind sh:IRI ;
    # Range specified in ontology; in theory shouldn't need to specify here,
    # since validation *should* factor in ontology axioms.
    sh:class bf:Status ;

    . 
            
:bf_subject
    a sh:PropertyShape ;
    sh:path bf:subject ;
    sh:nodeKind sh:IRI ;
    .
       
:bf_title 
    a sh:PropertyShape ;
    sh:path bf:title ;
    sh:nodeKind sh:IRI ; 
    sh:class bf:Title ;
    . 

:crm_P2_has_type
    a sh:PropertyShape ;
    sh:nodeKind sh:IRI ;
    sh:class skos:Concept ;
    .
           
:rdf_type
    a sh:PropertyShape ;
    sh:path rdf:type ;
    sh:nodeKind sh:IRI ;
    .
    
:rdf_value
    a sh:PropertyShape ;
    sh:path rdf:value ;
    # Do not specify sh:nodeKind; leave for implementations to define 
    # according to context.
    .
